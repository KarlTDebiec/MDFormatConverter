#   md_format_converter.convert.tcl
#
#   Copyright (C) 2012-2015 Karl T Debiec
#   All rights reserved.
#
#   This software may be modified and distributed under the terms of the
#   BSD license. See the LICENSE file for details.
################################# PROCEDURES ##################################
proc usage {} {
    puts "usage: vmd -dispdev text -e convert.tcl -args ARGUMENTS"
}

proc help {} {
    usage
    puts ""
    puts "optional arguments:"
    puts "  -h, --help            show this help message and exit"
    puts "  -d, --debug           Enable debug output"
    puts ""
    puts "input:"
    puts "  -input INPUTSPEC      Input file and settings, may be specified multiple"
    puts "                        times. Settings are provided in the format"
    puts "                        setting_1=value_1:setting_2=value_2:setting_3=value_3."
    puts "                        Supported settings are:"
    puts "                          filename: path to input file"
    puts "                          format: format of input file"
    puts "                          first: first frame to read"
    puts "                          last: last frame to read"
    puts "                          step: interval between frames"
    puts ""
    puts "output:"
    puts "  -output OUTPUTSPEC    Output file and settings, may be specified multiple"
    puts "                        times. Settings are provided in the format"
    puts "                        setting_1=value_1:setting_2=value_2:setting_3=value_3."
    puts "                        Supported settings are:"
    puts "                          filename: path to input file"
    puts "                          format: format of input file"
    puts "                          selection: atom selection to output; '_' are"
    puts "                            replaced with ' '"
    puts "                          first: first frame to read"
    puts "                          last: last frame to read"
    puts "                          step: interval between frames"
    puts "                        If first and last are both -1, only the topology will"
    puts "                        be read and all coordinates will be discarded."
}

proc write_mol2_manual_bonds { filename selection first last step } {
    package require topotools

    # Initialize
    set atom_filename  "$filename\_temp_atom"
    set bond_filename  "$filename\_temp_bond"

    # Output atom information to temporary file
    animate write mol2 $atom_filename sel $selection \
      beg $first end $last skip $step waitfor all 0

    # Output bond information to temporary file
    set bond_outfile [open $bond_filename "w"]
    set bond_index 1
    set bondlist [topo getbondlist order]

    puts $bond_outfile "@<TRIPOS>BOND"
    foreach bond $bondlist {
        puts $bond_outfile [format "%5d%6d%6d%3d" \
          $bond_index \
          [expr [lindex $bond 0] + 1] \
          [expr [lindex $bond 1] + 1] \
          [expr int([lindex $bond 2])]]
        set bond_index [expr $bond_index+1]
    }
    close $bond_outfile

    # Combine files
    set final_outfile [open $filename "w"]

    puts $final_outfile "@<TRIPOS>MOLECULE"
    puts $final_outfile "generated by VMD; bonds written manually"
    puts $final_outfile [format "%5d%5d%5d%5d%5d" \
          [topo numatoms] [topo numbonds] "1" "0" "0"]
    puts $final_outfile "SMALL"
    puts $final_outfile "USER_CHARGES"
    puts $final_outfile ""

    set atom_infile [open $atom_filename "r"]
    set atom_lines [split [read $atom_infile] "\n"]
    set in_atom_section 0
    foreach atom_line $atom_lines {
        if [string equal "$atom_line" "@<TRIPOS>ATOM"] {
            set in_atom_section 1
        } elseif [string equal "$atom_line" "@<TRIPOS>SUBSTRUCTURE"] {
            break
        }
        if $in_atom_section {
            puts $final_outfile $atom_line
        }
    }
    close $atom_infile

    set bond_infile [open $bond_filename "r"]
    set bond_lines [split [read $bond_infile] "\n"]
    foreach bond_line $bond_lines {
        puts $final_outfile $bond_line
    }
    close $bond_infile

    puts $final_outfile "@<TRIPOS>SUBSTRUCTURE"
    puts $final_outfile "1 **** 1 TEMP 0 **** **** 0 ROOT"
    close $final_outfile

    # Clean up
    exec rm $atom_filename
    exec rm $bond_filename
}

proc convert { inputs outputs debug } {

    foreach input $inputs {

        # Set defaults
        set fields [split $input :]
        set format pdb
        set first  0
        set last  -1
        set step   1

        # Parse settings
        foreach field $fields {
            set key_value [split $field =]
            set key       [lindex $key_value 0]
            set value     [lindex $key_value 1]
            puts "$key $value"
            set $key $value
        }
        if [expr ! [info exists filename]] {
            puts "ERROR: '-input' argument must include filename"
            exit
        }
        if $debug {
            puts "DEBUG: filename  = $filename"
            puts "DEBUG: format    = $format"
            puts "DEBUG: first     = $first"
            puts "DEBUG: last      = $last"
            puts "DEBUG: step      = $step"
        }
        
        # Read infile
        if [expr ! [info exists topology_read]] {
            mol new $filename type $format first $first last $last step $step waitfor all
            set topology_read true
        } else {
            mol addfile $filename type $format first $first last $last step $step waitfor all 0
        }

        # Delete all frames if specified (useful for loading topology)
        if {$first == -1 && $last == -1} {
            animate delete all 0
        }

        if $debug {
            set nframes [molinfo 0 get numframes]
            puts "DEBUG: n_frames  = $nframes"
        }
    }

    foreach output $outputs {

        # Set defaults
        set fields [split $output :]
        set format pdb
        set selection all
        set first  0
        set last  -1
        set step   1

        # Parse setings
        foreach field $fields {
            set key_value [split $field =]
            set key       [lindex $key_value 0]
            set value     [lindex $key_value 1]
            puts "$key $value"
            set $key $value
        }
        if [expr ! [info exists filename]] {
            puts "ERROR: '-output' argument must include filename"
            exit
        }
        set selection [regsub -all {_} $selection " "]

        if $debug {
            set nframes [molinfo 0 get numframes]
            puts "FILENAME  = $filename"
            puts "FORMAT    = $format"
            puts "SELECTION = $selection"
            puts "FIRST     = $first"
            puts "LAST      = $last"
            puts "STEP      = $step"
            puts "N_FRAMES  = $nframes"
        }

        # Write outfile
        set selection [atomselect 0 $selection]
        if [string equal $format "mol2_manual_bonds"] {
            write_mol2_manual_bonds $filename $selection $first $last $step
        } else {
            animate write $format $filename sel $selection \
              beg $first end $last skip $step waitfor all 0
        }
    }
}

#################################### MAIN #####################################

# Set defaults
set inputs [list]
set outputs [list]
set debug 0

# Parse arguments
while {[llength $argv] > 0} {
    set arg [lindex $argv 0]
    set argv [lrange $argv 1 end]
    if {($arg == "-h") || ($arg == "--help")} {
        help
        exit
    } elseif {($arg == "-d") || ($arg == "--debug")} {
        set debug 1
    } elseif {$arg == "-input"} {
        set mode "input"
    } elseif {$arg == "-output"} {
        set mode "output"
    } elseif {$mode == "input"} {
        lappend inputs $arg
    } elseif {$mode == "output"} {
        lappend outputs $arg
    } else {
        usage
    }
}

convert $inputs $outputs $debug
exit
